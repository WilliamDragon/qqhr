1.java多线程由几种实现方式
 （1）继承Threadl类（2）实现Runable接口（3）实现Callable接口通过FutureTask包装器来创建Thread线程
 （4）通过线程池创建线程，使用线程池接口ExecutorService结合Callable,Future实现由返回结果的多线程
2. 禁止使用Executors创建线程池的与原因
 （1）Executors.newCacheThreadPool和Executor.newScheduledThreadPool两个方法最大线程数均为Integer.MAX_VALUE 如果达到上线 会一直消耗CPU,进而肯定会抛出OOM
 （2）Executor.newSingleThreadPoll和Executor.newFixedThreadPool两个方法的workQueue参数均为new LinkedBlockingQueue<Runable>(),容量为Integer.VALUE，如果请求非常大会发生OOM
  以上除了java8新增的方法 Executor.newWorkStealingPool方法外，其他方法均有OOM风险  实际建议使用newCacheThreadPool 自定义实现，队列设为固定容量队列，自定义实现拒接策略。
3. 线程池参数
   （1）corePoolSize:核心线程数（2）maximumPoolSize:最大线程数（3）keepAliveTime:线程空闲时间（4）unit: 时间单位
   （5）workQueue:缓存队列，线程数大于核心线程数时，会进入缓存队列
   （6）threadFactory:线程工厂 用来生产一组相同任务的线程，主要用于生成线程名称的前缀，是否为守护线程优先级等，设置有意义的线程名称前缀有利于在进行虚拟机分析时，知道线程是由哪个线程工厂创建的
   （7）handler:执行拒绝策略对象(替换老的啊，直接拒绝啊，还可以自定义拒绝策略等)可看做是限流的保护
4.多线程就会涉及到锁，说一下AQS
 （1）AQS依赖于CLH队列实现 先进先出的队列 是一个双线链表，里面由两个主要变量 一个state （volite修饰的）代表加锁状态，另一个exclusiveOwnerThread 用来记录当前加锁的是哪个线程 初始化为空
 （2）AQS的加锁过程  @1 （互斥锁） 首先一个线程进来 尝试CAS（原子操作） 如果加获取成功 就设置state为1，再把当前线程赋值给exclusiveOwnerThread变量。@2 如果此时又来一个线程，
     尝试CAS,如失败，在看是不是自己加的锁（加锁线程），不是，就放入等待队列，依此类推.@3 如果线程1释放锁，会通知线程2 ，此时线程2尝试CAS 先进先出以此类推
5. AQS 主要用到了什么模式
  模板模式  AQS类有些方法是自己没有实现的，要求子类去实现，这就是典型的模板模式
6. 读写锁 readLock和writeLock 方法都是通过调用Sync的方法实现的
   AQS的状态state是4字节32位， 读锁用高16位（sharedCount）,写锁用低16位（exclusiveCount），只有线程获取了写锁，该线程该能重入读锁
   ReentrantLock中包含了公平锁和非公平锁两种锁
   公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。除非一种情况，该线程已经获取锁了，此时重入不用排队
   优点：所有的线程都能得到资源，不会饿死在队列中。 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。
   非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。
   优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。 缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。
7. 尾分叉
   在多线程环境下，比如多两个线程（线程1，线程2）同时加入了队列，那么只能有一个线程（比如线程1）可以成功的把自己设置成链表尾部， 此时如果从链表头开始遍历，就会遍历不到线程2，导致漏掉2， 所以要从链表尾部去遍历，这是就不会漏掉了
8. 无锁->偏向锁->轻量级锁->重量级锁
   对象头里面有一个MarkWork 这里面有一位  是否是偏向锁标记， 当第一个线程进来， 会把这个标记设置为1，代表已经是偏向锁了，此时在进来第二个线程，会通过CAS自旋 此时会升级成轻量级锁，如果大量的
   线程进来同时竞争，就会升级成重量级锁
   重量级锁之所以浪费时间， 是因为每次唤醒线程都需要操作系统来做处理
9.自旋  如果自旋可以获取锁，那么就会多自旋几次，  如果自旋不成功， 那么就会少自旋几次，甚至会直接加入到等待队列中
//====================================================================================================================================
1.concurrentHashMap
  1.7concurrentHashMap是由segment和hashEntry组成， 每一个segment实现了ReentankLock,所以segment是一个重入锁，hashEntry用于存储键值对， 并发度默认值为16
  1.8 取消分段锁，采用Node数据+CAS+Synchronized来保证并发安全，数据结构和HashMap1.8结构类似，数组+链表/红黑树。java8 在链表超过8 转换成红黑树，时间复杂度由O(N)变为O(logN).
  synchronized 只锁定当前链表或红黑树的首节点，这样只要hash不冲突，就不会发生并发，效率又提升N倍。
  由此抛出的问题：
  1.8concurrentHashMap中的链表换成二叉树可以吗多
  原因：不可以，极端情况可能形成链表
  为什么要用synchronized，cas不是已经可以保证操作的线程安全吗？
  原因：CAS也是适用一些场合的，比如资源竞争小时，是非常适用的，不用进行内核态和用户态之间的线程上下文切换，同时自旋概率也会大大减少，提升性能，但资源竞争激烈时（比如大量线程对同一资源进行写和读操作）并不适用，自旋概率会大大增加，从而浪费CPU资源，降低性能
2.CAS
  他是一条并发原语，是原子操作，主要是比较内存值和期望值是否相同，相同则更新新值
  存在比较大的问题，就是ABA问题， 可用版本号解决
3.LongAdder
  有一个base值， 并发度不高时，多个线程通过CAS取争抢这个base, 并发度高是，会新建一个cells数组， 线程如果竞争不到其中一个cell,就会去竞争其他cell, 最后每个cell做一个汇总在和base在做汇总来实现的思想
4.负载因子 0.75
  如果负载因子太大比如1，那么数组就会特别密集，发生冲突的情况就会增加，可能会加剧链表的快速形成，影响性能
  如果负载因子太小比如0.5，那么数组就会特别稀疏，会占用比较大的内存，存储了数量比较少的数，比较浪费
  0.75与泊松分布公式有关系，当0.75时带入公式时候 计算长度等于8时的概率很低0.000000006，所以当链表超过8时，转换成红黑树
5.hashMap多线程导致死循环问题
  主要是因为1.8之前，链表采用头插法，在reHash时候可能发生循环，也可能发生数据丢失，所以多线程不建议用，建议用concurrentHashMap
  1.8 时候采用尾插法，解决了死循环的问题，但是还存在数据覆盖（数据丢失）的情况
6.快速失败 java.util包下的集合都是快速失败的
  安全失败 java.util.concurrent包下的容器都是安全失败
====================================================================================================================
1.@Autowired @Resource
  @Autowired是由Spring提供，@Resource是由java提供
  前者默认按照byType注入， 默认情况下要求依赖对象不能为空，如果想允许为空 可以设置required=false
  后者默认按照byName注入，如果byName找不到，才会按byType方方式注入，但是一但指定了名字，就只能按照名字注入了
2.Spring怎么解决循环依赖问题的
   三级缓存， 一级缓存存储的是 实例化 初始化 都完成的对象；二级缓存 实例化完成，初始化未完成的对象； 三级缓存 是对象的工厂
  A依赖于B,B依赖于A
  首先A注入属性时候，发现依赖B,转而去实例化B
  同样创建对象B,注入时发现依赖与对象A,依此从一级到三级缓存中查询对象A,此时从三级缓存中拿到对象A,
  把A放到二级缓存，同时删除三级缓存的对象A,此时,B已经实例化完成并初始化完成，把B放入一级缓存
  接着继续创建A,此时顺利从一级缓存拿到实例化和初始化都完成的B,此时A也实例化和初始化都完成了，删除二级缓存中的A，并把A放入一级缓存
  最后  一级缓存中 AB对象都存在了
  因此， 由于把实例化和初始化的流程分开了， 如果都是用构造器的话，就没法分离这个操作了，所以都是用构造器就无法解决循环依赖的问题了
3.DI IOC IOC什么作用啊
4.Spring框架中都用到了那些设计模式
 （1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例
 （2）单例模式：Bean默认为单例模式
 （3）代理模式：AOP功能用到了JDK动态代理和CGLIB动态代理
 （4）模板方法：用来解决代码重复问题，比如，RestTemplate,JmsTemplate,JpaTemplate
 （5）观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知被制动更新，比如Spring中listener得实现-ApplicationListener
5.单例模式  详见单例代码
6.SpringMvc 从前端请求到和后端相应得过程
 （1）用户发送请求至前端控制器DispatcherServlet;
 （2）DispatcherServlet收到请求后，调用处理器映射器HandlerMapping,请求得到具体得Handler,并返回DispatcherServlet
 （3）DispatcherServlet在调用处理器适配器HandlerAdapter,经过具体处理后返回ModelAndView给DispatcherServlet
 （4）DispatcherServlet在将ModelAndView 传给视图解析器 ViewResolver,解析后返回具体的View
 （5）DispatcherServlet在对View 进行视图渲染（将模型数据填充到视图中）
 （6）DispatcherServlet响应客户
==================================================================================================
1.zookeeper 的几个特性
（1）持久节点：一旦创建就一直存在，即使集群宕机也存在， 除非手动删除
（2）临时节点：其生命周期是与客户端回话（session）绑定的，会话消失节点消失。并且，临时节点只能做叶子节点，不能做子节点
（3）持久顺序节点：除具有持久节点的特性外，子节点的名称还具有顺序性
（4）临时顺序节点：除具有临时顺序节点特性外，子节点的名称还具有顺序性
2.zookeeper TTL机制
在zookepper中，当你创建一个节点， 如果这个节点在规定的TTL时间没有被更新， 并且这个节点没有子节点， 那么这个节点则会被删除
3.zookeeper watch机制的特点
（1）一次性触发数据发生改变时，一个watch event会被发送到client,但是client 只会收到一次通知，是一次性的
（2）watch event是异步发送的，不能期望能够监控到每次节点的变化，zookeeper只能保证最终一致性，并不能保证强一致性。
4.zookeeper 实现分布式锁的机制
 （1）zk由一把锁，就是一个节点，当多个客户端请求加锁时，第一个客户端就会创建一个临时节点，当第一个释放锁的时候，其他所有客户端
     都会被通知同时竞争这一把锁。
  存在问题， 当第一个客户端释放锁的时候，也就是临时节点被删除的时候，此时会唤醒其他所有客户端同时竞争，如果有成千上万的客户端同时竞争，
  那么最后只能有一个获取到锁，这样其他999的都获取不到，这样白白浪费了资源（这就是“惊群”现象，也叫“羊群”现象）
 （2）zk由一把锁，就是一个节点，当多个客户端请求加锁时，第一个客户端就会创建一个临时顺序节点（000001），发现它是最小的时候，就会加锁成功，
     其他客户端来加锁的时候，就会依次创建临时顺序节点（000002，000003...）在判断如果不是最小的，那么就会监听前一个节点，当第一个客户端
     释放锁的时候，这个0000001节点就会消失，此时0000002就会被通知，进而加锁成功，依此类推。
5.zookepper 选举机制
  在启动的时候会有依此选举，在宕机时候也会选举，这又什么区别呢，都是怎么去选举的？
  （1）集群中互相都会通信的，第一次都选举自己myid,zxid
  （2）判断选票是否是有效的，是不是looking状态， 然后互相比较，先比较zxid,如果一样就在比较myid,然后更新，再次投票选举
  （3）直到判断集群中有过半的选票都是同一台机器的时候，那么此时就选举成功
  （4）各自机器更新自己的状态，是follower就更新状态为FOLLOWING,如果是leader,就更新成LEADING
  宕机时选举
  （1）如果有服务宕机，此时集群停止对外服务，所以服务变更状态为looking(除observer之外)
  （2）此时每个server会都投出选票，剩下的过程就和启动时选举一样了
5.在选举过程中，节点会有那些状态
    looking（寻找leader状态）,following（跟随者状态）,leading（leader状态）,observer(该节点不参与选举)
6.zookeeper的znode最多可以存储多大数据
    官方给的解释是1M，但是不建议存储太大的数据
7.
